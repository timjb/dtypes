-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Initial project template from stack
--   
--   Please see README.md
@package ftypes
@version 0.1.0.0

module FTypes.Internal.TH.Helpers

-- | Generates `case $val of { $pat -&gt; $exp }`
destructure :: ExpQ -> PatQ -> ExpQ -> ExpQ

-- | Generates `f arg1 ... argn`
appEs :: ExpQ -> [ExpQ] -> ExpQ

-- | Generates `f <a>*</a> arg1 <a>*</a> ... <a>*</a> argn`
apAppEs :: ExpQ -> [ExpQ] -> ExpQ

-- | Generates `f <a>$</a> arg1 <a>*</a> ... <a>*</a> argn`
liftAppEs :: ExpQ -> [ExpQ] -> ExpQ

-- | Extract the name from a TyVarBndr.
nameFromTyVarBndr :: TyVarBndr -> Name

-- | Apply arguments to a type constructor.
conAppsT :: Name -> [Type] -> Type

module FTypes.Compose
newtype Compose (f :: k -> *) (g :: l -> k) (x :: l)
Compose :: f (g x) -> Compose
[getCompose] :: Compose -> f (g x)
instance (GHC.Base.Functor f, GHC.Base.Functor g) => GHC.Base.Functor (FTypes.Compose.Compose f g)

module FTypes.Trafo

-- | Polymorphic family of functions between f and g. If f and g are both
--   functors, this is the type of natural transformations between them.
type Trafo (f :: k -> *) (g :: k -> *) = forall (a :: k). f a -> g a
type (==>) f g = Trafo f g
newtype TrafoComp f g a
TrafoComp :: (f a -> g a) -> TrafoComp f g a
[unTrafoComp] :: TrafoComp f g a -> f a -> g a
type (==>>) f g = TrafoComp f g

-- | Apply a transformation
($$) :: TrafoComp f g a -> f a -> g a

module FTypes.Classes.HasFType
class HasFType t where type family FType t :: (* -> *) -> *
fiso :: HasFType t => t -> FType t Identity
fosi :: HasFType t => FType t Identity -> t

module FTypes.Classes.FFunctor
class FFunctor (r :: (k -> *) -> *) where x <<$ r = ffmap (const x) r
ffmap :: FFunctor r => (f ==> g) -> r f -> r g

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<<$) :: FFunctor r => (forall a. g a) -> r f -> r g
(<<$>>) :: FFunctor r => (f ==> g) -> r f -> r g

module FTypes.Classes.FApplicative
class FFunctor r => FApplicative (r :: (k -> *) -> *) where s *>> t = (wrap1 id <<$ s) <<*>> t (<<*) = fliftA2 const
fpure :: FApplicative r => (forall (a :: k). f a) -> r f
(<<*>>) :: FApplicative r => r (f ==>> g) -> r f -> r g
(*>>) :: FApplicative r => r f -> r g -> r g
(<<*) :: FApplicative r => r f -> r g -> r f
fpureTrafo :: FApplicative r => (f ==> g) -> r (f ==>> g)
fliftA1 :: FFunctor r => (forall a. f a -> g a) -> r f -> r g
fliftA2 :: FApplicative r => (forall a. f a -> g a -> h a) -> r f -> r g -> r h
fliftA3 :: FApplicative r => (forall a. f a -> g a -> h a -> i a) -> r f -> r g -> r h -> r i
fliftA4 :: FApplicative r => (forall a. f a -> g a -> h a -> i a -> j a) -> r f -> r g -> r h -> r i -> r j
fliftA5 :: FApplicative r => (forall a. f a -> g a -> h a -> i a -> j a -> k a) -> r f -> r g -> r h -> r i -> r j -> r k
fliftA6 :: FApplicative r => (forall a. f a -> g a -> h a -> i a -> j a -> k a -> l a) -> r f -> r g -> r h -> r i -> r j -> r k -> r l
fliftA7 :: FApplicative r => (forall a. f a -> g a -> h a -> i a -> j a -> k a -> l a -> m a) -> r f -> r g -> r h -> r i -> r j -> r k -> r l -> r m
fliftA8 :: FApplicative r => (forall a. f a -> g a -> h a -> i a -> j a -> k a -> l a -> m a -> n a) -> r f -> r g -> r h -> r i -> r j -> r k -> r l -> r m -> r n

module FTypes.Classes.FTraversable
class FFunctor r => FTraversable (r :: (k -> *) -> *) where ftraverse f = fsequenceA . ffmap f fsequenceA = ftraverse id
ftraverse :: (FTraversable r, Applicative g) => (f ==> Compose g h) -> r f -> g (r h)
fsequenceA :: (FTraversable r, Applicative g) => r (Compose g h) -> g (r h)
ftraverse' :: (FTraversable r, Applicative g) => (f ==> g) -> r f -> g (r Identity)
fsequenceA' :: (FTraversable r, Applicative f) => r f -> f (r Identity)
ftoList :: FTraversable rec => rec (Const a) -> [a]

module FTypes.Classes.FChoice
data (:+:) f g a
LeftF :: (f a) -> (:+:) f g a
RightF :: (g a) -> (:+:) f g a
class FFunctor rec => FChoice (rec :: (k -> *) -> *)
fchoose :: FChoice rec => rec (f :+: g) -> Either (rec f) (rec g)

module FTypes.Classes

module FTypes.Combinators
newtype FApply (x :: k) (f :: k -> *)
FApply :: f x -> FApply
[unFApply] :: FApply -> f x
data FProd (r :: k -> *) (s :: k -> *) (f :: k)
FProd :: (r f) -> (s f) -> FProd
data FSum (r :: k -> *) (s :: k -> *) (f :: k)
FSum1 :: (r f) -> FSum
FSum2 :: (s f) -> FSum
instance forall (k :: BOX) (x :: k). FTypes.Classes.FFunctor.FFunctor (FTypes.Combinators.FApply x)
instance forall (k :: BOX) (x :: k). FTypes.Classes.FApplicative.FApplicative (FTypes.Combinators.FApply x)
instance forall (k :: BOX) (x :: k). FTypes.Classes.FTraversable.FTraversable (FTypes.Combinators.FApply x)
instance forall (k :: BOX) (r :: (k -> *) -> *) (s :: (k -> *) -> *). (FTypes.Classes.FFunctor.FFunctor r, FTypes.Classes.FFunctor.FFunctor s) => FTypes.Classes.FFunctor.FFunctor (FTypes.Combinators.FProd r s)
instance forall (k :: BOX) (r :: (k -> *) -> *) (s :: (k -> *) -> *). (FTypes.Classes.FApplicative.FApplicative r, FTypes.Classes.FApplicative.FApplicative s) => FTypes.Classes.FApplicative.FApplicative (FTypes.Combinators.FProd r s)
instance forall (k :: BOX) (r :: (k -> *) -> *) (s :: (k -> *) -> *). (FTypes.Classes.FTraversable.FTraversable r, FTypes.Classes.FTraversable.FTraversable s) => FTypes.Classes.FTraversable.FTraversable (FTypes.Combinators.FProd r s)
instance forall (k :: BOX) (r :: (k -> *) -> *) (s :: (k -> *) -> *). (FTypes.Classes.FFunctor.FFunctor r, FTypes.Classes.FFunctor.FFunctor s) => FTypes.Classes.FFunctor.FFunctor (FTypes.Combinators.FSum r s)
instance forall (k :: BOX) (r :: (k -> *) -> *) (s :: (k -> *) -> *). (FTypes.Classes.FTraversable.FTraversable r, FTypes.Classes.FTraversable.FTraversable s) => FTypes.Classes.FTraversable.FTraversable (FTypes.Combinators.FSum r s)

module FTypes.TH
makeFType :: Name -> DecsQ
instance GHC.Show.Show FTypes.TH.SimpleTypeInfo
instance GHC.Show.Show FTypes.TH.SimpleConstrInfo

module FTypes.Precompose
newtype Precompose r f g
Precompose :: r (Compose g f) -> Precompose r f g
[getPrecompose] :: Precompose r f g -> r (Compose g f)
instance FTypes.Classes.FFunctor.FFunctor r => FTypes.Classes.FFunctor.FFunctor (FTypes.Precompose.Precompose r f)
instance FTypes.Classes.FApplicative.FApplicative r => FTypes.Classes.FApplicative.FApplicative (FTypes.Precompose.Precompose r f)
instance FTypes.Classes.FTraversable.FTraversable r => FTypes.Classes.FTraversable.FTraversable (FTypes.Precompose.Precompose r f)

module FTypes.Postcompose
newtype Postcompose r f g
Postcompose :: r (Compose f g) -> Postcompose r f g
[getPostcompose] :: Postcompose r f g -> r (Compose f g)
instance (FTypes.Classes.FFunctor.FFunctor rec, GHC.Base.Functor f) => FTypes.Classes.FFunctor.FFunctor (FTypes.Postcompose.Postcompose rec f)
instance (FTypes.Classes.FApplicative.FApplicative rec, GHC.Base.Applicative f) => FTypes.Classes.FApplicative.FApplicative (FTypes.Postcompose.Postcompose rec f)
instance (FTypes.Classes.FTraversable.FTraversable rec, Data.Traversable.Traversable f) => FTypes.Classes.FTraversable.FTraversable (FTypes.Postcompose.Postcompose rec f)

module FTypes
